<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trefoil Knot - Interactive 3D Visualizer</title>
    <meta name="description" content="An interactive 3D visualization of the trefoil knot with real-time parameter controls, built with Three.js">
    <meta name="keywords" content="trefoil knot, 3D visualization, Three.js, mathematics, interactive">
    <meta name="author" content="Tansu √ñz√ßelebi">
    
    <!-- PWA Support -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4a9eff">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Trefoil Knot - Interactive 3D Visualizer">
    <meta property="og:description" content="An interactive 3D visualization of the trefoil knot with real-time parameter controls, built with Three.js">
    <meta property="og:type" content="website">
    <meta property="og:url" content="">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Trefoil Knot - Interactive 3D Visualizer">
    <meta name="twitter:description" content="An interactive 3D visualization of the trefoil knot with real-time parameter controls, built with Three.js">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect fill='%234a9eff' width='32' height='32' rx='4'/%3E%3Cpath fill='white' d='M16 8c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 6c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2-0.9 2-2 2z'/%3E%3C/svg%3E">
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="container"></div>
    
    <!-- Info Button -->
    <div class="panel info-button" id="info-btn">‚ÑπÔ∏è</div>
    
    <!-- Controls Hint -->
    <div class="panel controls-hint">
        üñ±Ô∏è Drag ‚Ä¢ üñ±Ô∏è Scroll ‚Ä¢ üëÜ Touch
    </div>

    <!-- Info Modal -->
    <div class="info-modal" id="info-modal">
        <div class="info-content">
            <button class="info-close" id="info-close">√ó</button>
            <div class="info-name">Tansu √ñz√ßelebi</div>
            <div class="info-year">2025</div>
        </div>
    </div>

    <!-- Compact Controls will be injected by controls.js -->

    <!-- Speed Control -->
    <div class="panel speed-panel">
        <div class="drag-handle"></div>
        <div class="control-item">
            <label for="rotation-speed">Speed</label>
            <input type="range" id="rotation-speed" min="0" max="3" value="1" step="0.1">
            <span id="rotation-speed-val">1.0</span>
        </div>
    </div>

    <!-- Three.js CDN with fallbacks -->
    <script>
        function loadThreeJSFallback() {
            console.log('Primary CDN failed, trying fallback...');
            var script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js';
            script.onerror = function() {
                console.error('All Three.js CDN sources failed. Please check your internet connection.');
                showErrorMessage();
            };
            script.onload = function() {
                console.log('Three.js loaded from fallback CDN');
                // Initialize app after successful load
                if (typeof initializeApp === 'function') {
                    initializeApp();
                }
            };
            document.head.appendChild(script);
        }
        
        function showErrorMessage() {
            document.body.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460); color: white; font-family: Arial, sans-serif;">
                    <div style="text-align: center; background: rgba(0,0,0,0.8); padding: 40px; border-radius: 12px; border: 1px solid #ff6b35;">
                        <h2 style="color: #ff6b35; margin-bottom: 20px;">Unable to Load 3D Engine</h2>
                        <p style="margin-bottom: 20px;">The Three.js library could not be loaded from external sources.</p>
                        <p>Please check your internet connection and refresh the page.</p>
                        <button onclick="location.reload()" style="background: #4a9eff; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-top: 20px;">Retry</button>
                    </div>
                </div>
            `;
        }
    </script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js" 
            onload="console.log('Three.js loaded from primary CDN'); if(typeof initializeApp === 'function') initializeApp();" 
            onerror="loadThreeJSFallback()"></script>
    
    <!-- Controls Module -->
    <script src="controls.js"></script>

    <script>
        // Check if Three.js is available before initializing
        function initializeApp() {
            if (typeof THREE === 'undefined') {
                console.error('Three.js not loaded, retrying...');
                // Try up to 5 times with increasing delays
                let retryCount = 0;
                const maxRetries = 5;
                
                function retry() {
                    retryCount++;
                    if (retryCount <= maxRetries && typeof THREE === 'undefined') {
                        console.log(`Retry attempt ${retryCount}/${maxRetries}`);
                        setTimeout(retry, retryCount * 500); // 500ms, 1s, 1.5s, 2s, 2.5s
                    } else if (typeof THREE === 'undefined') {
                        console.error('Failed to load Three.js after multiple attempts');
                        showErrorMessage();
                        return;
                    } else {
                        console.log('Three.js loaded successfully!');
                        startApp();
                    }
                }
                
                retry();
                return;
            }
            
            startApp();
        }

        function startApp() {

            // Three.js Scene Setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            const container = document.getElementById('container');
            if (container) {
                container.appendChild(renderer.domElement);
            }

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0x4a9eff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xff6b35, 0.6);
            pointLight.position.set(-10, -10, 10);
            scene.add(pointLight);

            // Mouse orbit controls
            const mouse = { 
                isDown: false, 
                prevX: 0, 
                prevY: 0,
                spherical: new THREE.Spherical(12, Math.PI / 3, Math.PI / 4)
            };

            // Parameters
            let params = {
                magnitude: 2.0,
                paramA: 0.5,
                paramB: 0.5,
                frequency: 1.0,
                baseRadius: 0.15,
                radiusVariation: 1.0,
                variationFreq: 3.0,
                rotationSpeed: 1.0,
                segments: 200
            };

            let trefoilMesh;

            // Trefoil knot parametric equations
            function trefoilKnot(t) {
                const { magnitude, paramA, paramB, frequency } = params;
                return new THREE.Vector3(
                    magnitude * (Math.sin(frequency * t) + paramA * Math.sin(3 * frequency * t)),
                    magnitude * (Math.cos(frequency * t) - paramA * Math.cos(3 * frequency * t)),
                    magnitude * paramB * Math.sin(2 * frequency * t)
                );
            }

            // Variable radius function
            function getRadius(t) {
                const { baseRadius, radiusVariation, variationFreq } = params;
                return baseRadius * (1 + radiusVariation * Math.sin(variationFreq * t));
            }

            // Create trefoil mesh
            function createTrefoilMesh() {
                if (trefoilMesh) {
                    scene.remove(trefoilMesh);
                    trefoilMesh.geometry.dispose();
                    trefoilMesh.material.dispose();
                }

                const { segments } = params;
                const points = [];
                const radii = [];

                // Generate curve points and radii
                for (let i = 0; i <= segments; i++) {
                    const t = (i / segments) * 2 * Math.PI;
                    points.push(trefoilKnot(t));
                    radii.push(getRadius(t));
                }

                // Create tube geometry with variable radius
                const curve = new THREE.CatmullRomCurve3(points);
                curve.closed = true;

                // Custom tube geometry with variable radius
                const tubeGeometry = new THREE.TubeGeometry(curve, segments, 0.1, 8, true);
                
                // Modify vertices for variable radius
                const positionAttribute = tubeGeometry.getAttribute('position');
                const vertex = new THREE.Vector3();
                
                for (let i = 0; i < positionAttribute.count; i++) {
                    vertex.fromBufferAttribute(positionAttribute, i);
                    const segmentIndex = Math.floor(i / 8);
                    const radius = radii[segmentIndex] || radii[radii.length - 1];
                    
                    // Scale the radius
                    const distance = Math.sqrt(vertex.x * vertex.x + vertex.y * vertex.y);
                    if (distance > 0) {
                        const scale = radius / 0.1; // 0.1 is the base tube radius
                        vertex.x *= scale;
                        vertex.y *= scale;
                    }
                    
                    positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }

                positionAttribute.needsUpdate = true;
                tubeGeometry.computeVertexNormals();

                // Material with gradient-like coloring
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4a9eff,
                    shininess: 100,
                    specular: 0x111111
                });

                trefoilMesh = new THREE.Mesh(tubeGeometry, material);
                trefoilMesh.castShadow = true;
                trefoilMesh.receiveShadow = true;
                scene.add(trefoilMesh);
            }

            // Camera positioning
            camera.position.copy(new THREE.Vector3().setFromSpherical(mouse.spherical));
            camera.lookAt(0, 0, 0);

            // Mouse controls
            function updateCamera() {
                camera.position.copy(new THREE.Vector3().setFromSpherical(mouse.spherical));
                camera.lookAt(0, 0, 0);
            }

            // Mouse events
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouse.isDown = true;
                mouse.prevX = e.clientX;
                mouse.prevY = e.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!mouse.isDown) return;
                
                const deltaX = e.clientX - mouse.prevX;
                const deltaY = e.clientY - mouse.prevY;
                
                mouse.spherical.theta -= deltaX * 0.01;
                mouse.spherical.phi += deltaY * 0.01;
                mouse.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, mouse.spherical.phi));
                
                updateCamera();
                
                mouse.prevX = e.clientX;
                mouse.prevY = e.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouse.isDown = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                mouse.spherical.radius += e.deltaY * 0.01;
                mouse.spherical.radius = Math.max(3, Math.min(20, mouse.spherical.radius));
                updateCamera();
            });

            // Touch events for mobile
            let touchStartX, touchStartY;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                mouse.isDown = true;
                mouse.prevX = touch.clientX;
                mouse.prevY = touch.clientY;
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!mouse.isDown || e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - mouse.prevX;
                const deltaY = touch.clientY - mouse.prevY;
                
                mouse.spherical.theta -= deltaX * 0.01;
                mouse.spherical.phi += deltaY * 0.01;
                mouse.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, mouse.spherical.phi));
                
                updateCamera();
                
                mouse.prevX = touch.clientX;
                mouse.prevY = touch.clientY;
            });

            renderer.domElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                mouse.isDown = false;
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                if (trefoilMesh) {
                    trefoilMesh.rotation.z += params.rotationSpeed * 0.01;
                }
                
                renderer.render(scene, camera);
            }

            // Draggable functionality for panels
            function makeDraggable(element) {
                let isDragging = false;
                let currentX, currentY, initialX, initialY;
                let moved = false;

                function dragStart(e) {
                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    
                    if (e.target === element || e.target.classList.contains('drag-handle')) {
                        initialX = clientX - (element.offsetLeft || 0);
                        initialY = clientY - (element.offsetTop || 0);
                        
                        if (e.target === element || e.target.classList.contains('drag-handle')) {
                            isDragging = true;
                            moved = false;
                            element.classList.add('dragging');
                        }
                    }
                }

                function dragEnd(e) {
                    if (isDragging) {
                        isDragging = false;
                        element.classList.remove('dragging');
                        
                        // Set a flag to indicate this element was moved
                        if (moved) {
                            element.setAttribute('data-moved', 'true');
                        }
                    }
                }

                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        moved = true;
                        
                        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                        
                        currentX = clientX - initialX;
                        currentY = clientY - initialY;

                        element.style.left = currentX + 'px';
                        element.style.top = currentY + 'px';
                    }
                }

                element.addEventListener('mousedown', dragStart);
                element.addEventListener('touchstart', dragStart, { passive: false });
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, { passive: false });
                
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('touchend', dragEnd);
            }

            // Info modal functionality
            const infoBtn = document.getElementById('info-btn');
            const infoModal = document.getElementById('info-modal');
            const infoClose = document.getElementById('info-close');
            
            let infoMoved = false;

            infoBtn.addEventListener('click', (e) => {
                infoMoved = infoBtn.getAttribute('data-moved') === 'true';
                if (!infoMoved) {
                    infoModal.classList.add('show');
                }
            });

            infoBtn.addEventListener('touchend', (e) => {
                infoMoved = infoBtn.getAttribute('data-moved') === 'true';
                if (!infoMoved) {
                    e.preventDefault();
                    infoModal.classList.add('show');
                }
            });

            infoClose.addEventListener('click', () => {
                infoModal.classList.remove('show');
            });

            infoModal.addEventListener('click', (event) => {
                if (event.target === infoModal) {
                    infoModal.classList.remove('show');
                }
            });

            // Setup controls
            let controlPanel;
            
            // Initialize control panel after trefoil mesh function is defined
            function initializeControls() {
                if (typeof ControlPanel !== 'undefined') {
                    controlPanel = new ControlPanel(params, createTrefoilMesh);
                    
                    // Make all panels draggable (including the newly created control panel)
                    const draggablePanels = document.querySelectorAll('.panel');
                    draggablePanels.forEach(panel => {
                        makeDraggable(panel);
                    });
                }
                
                // Setup speed control separately (it's not part of the main control panel)
                const speedSlider = document.getElementById('rotation-speed');
                const speedDisplay = document.getElementById('rotation-speed-val');
                
                if (speedSlider && speedDisplay) {
                    speedSlider.addEventListener('input', (e) => {
                        params.rotationSpeed = parseFloat(e.target.value);
                        speedDisplay.textContent = params.rotationSpeed.toFixed(1);
                    });
                }
            }

            // Initialize everything
            createTrefoilMesh();
            animate();
            
            // Initialize controls with a small delay to ensure ControlPanel is loaded
            setTimeout(initializeControls, 100);
        }

        // Start initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, checking for Three.js...');
            // Give some time for scripts to load
            setTimeout(initializeApp, 200);
        });
    </script>
</body>
</html>